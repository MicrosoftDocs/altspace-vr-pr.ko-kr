---
title: AltspaceVR 모바일 성능 가이드
description: '다양 한 Unity 속성을 사용 하 여 모바일 장치 (예: Oculus 퀘스트)에서 성능을 향상 하는 방법을 알아봅니다.'
ms.date: 04/20/2021
ms.topic: article
keywords: 세계 편집기, 성능, oculus, 퀘스트, unity, 질감, lightmaps, 통계, 프로파일러, 그리기 호출, altspacevr, 업 로더
ms.openlocfilehash: 9d6afba6fff85adfaa2ba290916f25c84c5377cd
ms.sourcegitcommit: 2db596ab5a1ecd4901a8c893741cc4d06f6aecea
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/25/2021
ms.locfileid: "112961260"
---
# <a name="altspacevr-mobile-performance-guide"></a><span data-ttu-id="7a723-104">AltspaceVR 모바일 성능 가이드</span><span class="sxs-lookup"><span data-stu-id="7a723-104">AltspaceVR Mobile Performance Guide</span></span>

## <a name="main-points"></a><span data-ttu-id="7a723-105">**기본 사항:**</span><span class="sxs-lookup"><span data-stu-id="7a723-105">**Main Points:**</span></span>

* <span data-ttu-id="7a723-106">**72 FPS의 Oculus** 퀘스트 1 및 2가 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-106">**72 FPS** on Oculus Quest 1 and 2, is the target.</span></span>
* <span data-ttu-id="7a723-107">**정적 일괄 처리를 통한 그리기 호출 감소** 는 **25 개 미만의 drawcalls** 에 대 한 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-107">**Reducing Draw Calls via Static Batching** is essential, aim for **less than 25 drawcalls**</span></span>
* <span data-ttu-id="7a723-108">정적 일괄 처리를 장려 하는 **개체 당 재질 하나** (여러 재질 개체를 개별 개체로 분할)</span><span class="sxs-lookup"><span data-stu-id="7a723-108">**One material per object** to encourage Static Batching (split up multi-material objects into separate objects).</span></span>
* <span data-ttu-id="7a723-109">대부분의 경우 환경의 **개체** 를 **' 정적 '** 으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-109">**Objects** in an environment should be set to **‘Static’** in most cases.</span></span>
* <span data-ttu-id="7a723-110">**Lightmap 1 개**, 전체 장면에 대해 1, 1, 1, 1, 텍셀, lightmap 크기 조정은 개체당 조정 되어야 합니다 (아래 차트 크기 조정).</span><span class="sxs-lookup"><span data-stu-id="7a723-110">**One lightmap per scene**, one 2k or one 4k for the whole scene, ~25 texels per unit, lightmap scaling should be tuned per object (scaling chart below)</span></span>
* <span data-ttu-id="7a723-111">**모바일 품질 셰이더** (즉, ' 모바일/확산 ' 등)를 사용 하 고, 많은 작업을 수행 하 고 프로브에서 그리기 호출을 추가 하는 Unity 표준 셰이더/.Pbr/리플렉션 프로브/라이트 프로브를 피합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-111">**Use Mobile-quality shaders** (that is, ‘Mobile/Diffuse’, etc.), avoid the Unity Standard shader/PBR/Reflection Probes/Light Probes as they are heavy operations and in the case of the probes will add draw calls.</span></span>
* <span data-ttu-id="7a723-112">화면에서 **10만 미만의 삼각형**</span><span class="sxs-lookup"><span data-stu-id="7a723-112">**Less than 100k triangles** on-screen</span></span>
* <span data-ttu-id="7a723-113">**폐색 고르기** 를 사용 하면 폐색 고르기를 사용 하도록 설정 하는 데 필요한 사전 투자 비용이 발생 하지만 진단 패널을 사용 하 여 altspace의 프레임 속도에 미치는 영향을 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-113">**Occlusion Culling** can help reduce on-screen polygons, although there is an up-front cost to having occlusion culling enabled so measure the effect on framerate in Altspace using the Diagnostics Panel.</span></span>
* <span data-ttu-id="7a723-114">장면의 모든 **질감** 에 대해 **' Android에 대해 재정의 '** 를 사용 하 고 **RGB (a) 압축 된 6x6 블록 형식** 으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-114">For all **textures** in a scene, use **‘Override for Android’** and set them to **RGB(A) Compressed ASTC 6x6 block format**.</span></span>  <span data-ttu-id="7a723-115">Android 빌드 설정 압축을 기본 (파일/빌드 설정/a s s/질감 압축: ' 재정의 안 함 '에 있음)으로 그대로 둡니다. 그러면 Lightmaps가 o c 압축을 얻지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-115">Leave your Android Build Settings compression to default (found in: File/Build Settings/Android/Texture Compression: ‘Don’t override’), so that Lightmaps don’t get ASTC compression.</span></span>  <span data-ttu-id="7a723-116">위의 작업을 수행 하 고 개체 간에 자료를 공유 하 여 Android의 unity 패키지를 **10-20** x x x x x x x x로 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-116">By doing the above, and by sharing materials across objects, we try to keep our scene’s unity package to around **10-20 MB for Android**.</span></span>

<span data-ttu-id="7a723-117">일반적인 목표는 장치에서 허용 가능한 프레임을 적중 하는 것입니다. 즉, Oculus Quest 1과 2에서는 장면이 채워질 때 유리한 모든 지점에서 72 FPS로 실행 됩니다. 단, 60-72 FPS의 범위는 더 현실적인 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-117">The general goal is to hit an acceptable framerate across devices – on Oculus Quest 1 and 2 ideally the scene will run at 72 FPS from all vantage points when the scene is populated, although a range of 60-72 FPS is often a more realistic target.</span></span>

<span data-ttu-id="7a723-118">AltspaceVR 내에서 사용 중인 장치 ( **설정/지원/진단 패널/** a s s/FPS 아래에 있음)에서 프레임 속도를 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-118">Framerate can be measured within AltspaceVR on whichever device that you’re using (found in the AltspaceVR app under **Settings/Support/Show Diagnostics Panel/FPS**).</span></span>

<span data-ttu-id="7a723-119">사용 가능한 표준 Unity 도구의 런다운을 통해 장면을 보다 잘 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-119">A rundown of the standard Unity tools available to help you to better-optimize your scenes:</span></span>

## <a name="stats-panelframe-debuggerprofiler"></a><span data-ttu-id="7a723-120">**통계 패널/프레임 디버거/프로파일러**</span><span class="sxs-lookup"><span data-stu-id="7a723-120">**Stats Panel/Frame Debugger/Profiler**</span></span>

* <span data-ttu-id="7a723-121">이러한 도구는 장면 성능을 향상 시킬 수 있는 가장 좋은 친구입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-121">These tools will be your best friends in improving your scene's performance.</span></span>  <span data-ttu-id="7a723-122">장면을 재생 하지 않는 경우 (즉, 장면이 재생 되지 않을 때 자동 정적 일괄 처리가 발생 하지 않는 경우) 해당 값은 **편집기에서 재생 중인 동안에만 참조할** 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-122">They can **only be referenced while the scene is Playing in-editor**, as their values will be different from when the scene is not playing (that is, Automatic static batching won't be happening when the scene isn't playing)</span></span>

* <span data-ttu-id="7a723-123">**통계 패널** (' stats ' 아래 게임 보기에서 볼 수 있음)에는 저장 된 **일괄 처리/일괄 처리, Setpass 호출 및 프레임 속도가** 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-123">**Stats Panel** (viewable in Game View under 'Stats') will show you the amount of **Batches/Batches Saved, SetPass Calls, and Framerate**.</span></span>

    * <span data-ttu-id="7a723-124">일괄 처리 – 현재 카메라의 관점에서 볼 수 있는 현재 그리기 호출의 양입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-124">Batches – the amount of current draw calls that are visible from the current camera's perspective.</span></span>  <span data-ttu-id="7a723-125">환경에 대해 **25 개 미만의 일괄 처리** 는 목표를 목표로 하는 좋은 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-125">**Fewer than 25 batches** for an environment is a good target to aim for.</span></span>
    * <span data-ttu-id="7a723-126">저장 된 일괄 처리 (장면이 재생 되는 경우에만 표시 됨)- **정적 일괄 처리 또는 GPU 인스턴스** 를 통해 축소 된 크기 그리기 호출</span><span class="sxs-lookup"><span data-stu-id="7a723-126">Batches Saved (only visible when the scene is Playing)  – the amount draw calls that have been reduced via **Static Batching or GPU Instancing**</span></span>
    * <span data-ttu-id="7a723-127">SetPass 호출 – 장면에 표시 되는 다양 한 재질의 수</span><span class="sxs-lookup"><span data-stu-id="7a723-127">SetPass Calls – the number of different visible materials in a scene</span></span>
    * <span data-ttu-id="7a723-128">프레임 속도 – 게임 보기에서 초당 프레임의 양 (발생 하는 상황에 대 한 대략적인 정보를 제공 합니다. 대부분의 경우에는 백그라운드에서 항상 앱 내에서, 즉, fps는 항상 편집기의 기능을 사용 하는 것과는 다른 방식으로 앱 내에서, 헤드셋은 항상 앱 내에서 테스트 해야 함)</span><span class="sxs-lookup"><span data-stu-id="7a723-128">Framerate – the amount of frames-per-second in the Game view (gives you an approximate idea of what's happening; scenes should always be tested in-app, in-headset, using the Oculus Framerate panel as the fps readout will always be different than what's in-editor)</span></span>

* <span data-ttu-id="7a723-129">**프레임 디버거** (창/분석/프레임 디버거 아래에 있음).</span><span class="sxs-lookup"><span data-stu-id="7a723-129">**Frame Debugger** (found under Window/Analysis/Frame Debugger).</span></span>  <span data-ttu-id="7a723-130">Steroids의 Stats 패널을 사용 하면 최종 이미지를 만들기 위해 GPU에서 그리는 작업을 확인할 수 있습니다 .이 패널에는 첫 번째에서 마지막으로의 drawcalls 목록이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-130">The Stats Panel on steroids that, when enabled, will allow you to see what the GPU is drawing to create the final image, showing you a list of drawcalls from first to last.</span></span>  <span data-ttu-id="7a723-131">그리기 호출이 이전 그리기 호출로 일괄 처리 되지 않는 이유 (즉, '이 개체는 다른 자료를 사용 하는 개체 또는 '이 개체는 다른 Lightmap '를 사용 하는 경우)를 제공 하며, 장면에서 발생 하는 상황을 이해 하 고 특정 시각적 항목을 계산 하는 데 큰 도움이 되는 방법 및 이유를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-131">It will give you reasons for why a draw call wasn't batched with a previous draw call (that is, 'This object uses a different Material' or 'This object uses a different Lightmap'), and is an excellent way towards developing an understanding both of what's happening in your scene, and how and why certain visual choices can be computationally expensive.</span></span>

* <span data-ttu-id="7a723-132">**프로파일러** 는 게임을 실행 하는 동안 언제 든 지 어떤 컴퓨터에서 사용 되 고 있는지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-132">**Profiler** will show you what parts of the computer are being used at any point in time while the game is running.</span></span> <span data-ttu-id="7a723-133">성능을 bottlenecking 결정 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-133">Helpful in determining where performance is bottlenecking.</span></span>  <span data-ttu-id="7a723-134">예를 들어 장면에서 CPU 사용량이 많은 경우 그리기 호출이 너무 많거나, GPU 사용량이 많은 경우 여러 투명 화면을 포함 하 여 발생할 수 있는 너무 많은 그리기 (즉, 단일 픽셀이 렌더링 되어 최종 이미지를 생성 하는 횟수)가 너무 많을 수 있습니다. , 또는 개체가 뷰에서 추출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-134">For instance, if you are seeing heavy CPU usage in your scene, it could be that there are too many draw calls, or if you're seeing heavy GPU usage, there might be too much overdraw happening (that is, the number of times that a single pixel is rendered to produce the final image) which can be caused by having multiple transparent surfaces, or objects not being culled when out of view.</span></span>

## <a name="draw-calls-shadersmaterialsobjects"></a><span data-ttu-id="7a723-135">**그리기 호출 (셰이더/재질/개체)**</span><span class="sxs-lookup"><span data-stu-id="7a723-135">**Draw Calls (Shaders/Materials/Objects)**</span></span>

* <span data-ttu-id="7a723-136">셰이더, 재질 또는 개체를 렌더링 해야 할 때마다 CPU는 스위치의 GPU (' draw calls ', 것 구어체 **' drawcalls '**)를 지시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-136">Every time that a shader, material or object needs to be rendered, the CPU has to instruct the GPU of the switch (also known as 'draw calls', colloquially **'drawcalls'**).</span></span>  <span data-ttu-id="7a723-137">즉, 5 개의 셰이더, 10 개 자료 및 20 개 개체가 있는 경우이 중 가장 큰 것은 약 20 개의 drawcalls를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-137">That is, if you have 5 shaders, 10 materials, and 20 objects, with whichever is greatest; you'll have approximately 20 drawcalls.</span></span>  <span data-ttu-id="7a723-138">여러 lightmaps에 개체를 포함 하거나 장면에 두 개 이상의 실시간 조명이 있는 다른 항목 (즉, 한 지점 광원은 범위 내에 있는 모든 개체에 다른 drawcalls을 추가 함)을 포함 하는 다른 항목은 일반적으로 장면의 방향성이 아닌 다른 항목을 피해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-138">Other things that can multiply drawcalls include having objects on different lightmaps or having more than one real-time light in a scene (that is, one point light will add another drawcall to every object that is within its range), so generally anything other than a scene's directional light should be avoided.</span></span>  <span data-ttu-id="7a723-139">또한 리플렉션 프로브 및 밝은 프로브는 적중 하는 개체에 대 한 그리기 호출을 곱하여 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-139">Reflection probes and light probes will also multiply draw calls on whichever objects that they hit, so they should be avoided.</span></span>

* <span data-ttu-id="7a723-140">**정적 일괄 처리** 는 GPU로 전송 될 때 동일한 자료를 단일 개체로 공유 하는 일괄 처리 개체를 사용 합니다. 즉, 폐색 고르기를 사용 하 여 뷰를 삭제 하는 경우에는 위의 예에 있는 모든 개체를 ' 정적 '으로 설정 하 여 모든 재질에 대해 1 ~ 10 개의 drawcalls로 장면을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-140">**Static Batching** will batch objects that share like-materials into a single object when sent to the GPU (with Occlusion Culling discarding meshes that are out of view), so by setting all objects in the above example to 'Static', you would reduce the scene to approximately 10 drawcalls, 1 for every material.</span></span> 

* <span data-ttu-id="7a723-141">**자료 일괄 처리** 는 개체가 다른 개체와 동일한 자료를 포함 하는 경우에 발생 합니다. 그러나 개체에 여러 자료가 있으면 자료는 자료를 포함 하는 개체로 일괄 처리 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-141">**Material batches** occur when an object has the exact materials as another object, however if an object has multiple materials, it won't batch with an object that has fewer materials.</span></span>  <span data-ttu-id="7a723-142">이러한 이유로 인해 개체에는 **1 개의 재질만 있어야** 하 고, 여러 자료를 사용 하는 개체는 재질 마다 별도의 개체로 분할 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-142">For this reason: **Objects MUST only have 1 material**, and objects that use several materials should be split into separate objects per material.</span></span>  <span data-ttu-id="7a723-143">**질감 Atlasing** 을 통해 **재질 일괄 처리** 를 줄일 수 있습니다 (여러 고유 개체의 질감을 결합 하 여 모두 동일한 자료를 사용 하도록 단일 질감 시트를 공유).</span><span class="sxs-lookup"><span data-stu-id="7a723-143">**Material batches** can be reduced through **Texture Atlasing** (combining multiple unique object's textures to share a single texture sheet so that they all use the same material).</span></span>  <span data-ttu-id="7a723-144">가능 하면 아틀라스의 양을 단일 2k 또는 4k 질감/재질로 유지 해 보세요.</span><span class="sxs-lookup"><span data-stu-id="7a723-144">Try to keep the amount of Atlases down to a single 2k or 4k texture/material per scene if possible.</span></span>

## <a name="scene-complexity"></a><span data-ttu-id="7a723-145">**장면 복잡성**</span><span class="sxs-lookup"><span data-stu-id="7a723-145">**Scene Complexity**</span></span>

* <span data-ttu-id="7a723-146">**Geometry** – 환경에 대해 화면에 있는 삼각형을 10만 미만으로 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-146">**Geometry** – try to keep onscreen triangles for environments below 100k.</span></span>  <span data-ttu-id="7a723-147">Unity의 게임 패널에서 ' 통계 ' 탭을 사용 하 여 장면의 다양 한 유리한 점에서 적중 하는 삼각형 수를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-147">Use the ‘Stats’ tab in Unity’s Game panel to see what triangle counts you’re hitting from various vantage points in the scene.</span></span>  <span data-ttu-id="7a723-148">이와 같은 경우에는 너무 많은 삼각형 범위에서 중요 한 ' 주인공 ' props만 있는 ' 수백 '의 삼각형 범위에 속해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-148">Props as such should be in the ‘hundreds’ of triangles range, with only important ‘hero’ props in the thousands of triangles range.</span></span> 

* <span data-ttu-id="7a723-149">기술적으로 **는 lods (세부** 정보 메시 수준)를 사용할 수 있지만, Unity의 기본 lightmap 솔루션은 lods 간에 lightmap 데이터를 공유 하지 않으므로이 해상도에서 lods 스위치를 사용 하 여 lightmapping 아티팩트를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-149">You can technically use **LODs** (level of detail meshes), although Unity’s default lightmap solution does not share lightmap data between LODs, so you may get lightmapping artifacts when the LODs switch at this resolution.</span></span>  <span data-ttu-id="7a723-150">또는 개체가 낮은 LOD 메시를 포함 하지 않는 경우에도 단순 거리 고르기에 LOD 그룹 구성 요소를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-150">Alternatively, you can use the LOD Group component for simple Distance Culling, even if the object doesn’t have lower LOD meshes:</span></span>

![Unity의 LOD Group 창](images/world-building-lod-Group.png)

* <span data-ttu-id="7a723-152">**폐색 고르기** 는 카메라의 뷰 사이에만 렌더링 되는 개체 수를 줄이고 즉시 표시 됩니다. 즉, 뷰에서 폐색 개체는 추출입니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-152">**Occlusion Culling** reduces the number of objects that are rendered to only what is within the camera's view frustum, and that are immediately visible (that is, objects that are Occluded from view are Culled).</span></span>  <span data-ttu-id="7a723-153">폐색 고르기는 거의 항상 장면에 대해 구운 되어야 하며, 수준이 지원 되도록 디자인 되어야 합니다. 즉, 많은 수준이 있는 경우 벽 또는 초대형 개체를 사용 하 여 플레이어의 시야를 나눌 수 있으므로 항상 수준의 반대쪽 끝까지 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-153">Occlusion culling should almost always be baked for your scene, and levels should be designed to support it (that is, if you have a large level, walls or large objects can be used to break up the player's line-of-sight, so that they can't always see through to the opposite end of the level.</span></span>  <span data-ttu-id="7a723-154">기본 굽기 설정은 작동 하지만 ' 가장 작은 Occluder ' 또는 ' 가장 작은 구멍 ' 값을 축소 해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-154">The default bake settings should work, although you may have to shrink the 'Smallest Occluder' or 'Smallest Hole' values.</span></span>  <span data-ttu-id="7a723-155">개체 또는 투명 개체의 깨진 부분을 볼 수 있는 fence와 같은 개체의 경우 ' 정적 ' 드롭다운 메뉴에서 개체의 ' Occluder ' 상태를 해제 하 여 해당 개체가 잘못 폐색 되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-155">For objects like fences where you may be able to see through cracks in the object, or transparent objects, you should turn off the object's 'Occluder' status in the 'Static' drop-down menu so that objects behind it aren't erroneously occluded.</span></span> 

## <a name="lightmaps"></a><span data-ttu-id="7a723-156">**Lightmaps**</span><span class="sxs-lookup"><span data-stu-id="7a723-156">**Lightmaps**</span></span>

* <span data-ttu-id="7a723-157">그렇지 않은 경우에는 **장면 마다 하나의 lightmap** (모든 항목에 대해 1, 1, 4k 또는 4k)로 가장 이상적입니다. 고해상도의 lightmaps 수가 적을수록 더 낮은 해상도의 lightmaps 보다 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-157">Ideally just **one lightmap per scene** (one 2k or one 4k for everything), if not; fewer lightmaps of higher resolutions are better than many lightmaps of lower resolutions.</span></span>
* <span data-ttu-id="7a723-158">Lightmaps가 있거나 없는 개체는 서로 다른 일괄 처리에 있고 다른 lightmaps는 다른 일괄 처리에 포함 되기 때문에 여러 lightmaps를 설정 하면 그리기 호출 수에도 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-158">Having multiple lightmaps can also affect the number of draw calls, as objects that either have or don't have lightmaps will be on different batches, and other lightmaps will also be on different batches.</span></span>
* <span data-ttu-id="7a723-159">일반적으로 **단위당 25 텍셀 약 25** Lightmap 해상도는 충분 해야 합니다 (조명/장면 설정에서 해상도를 설정).</span><span class="sxs-lookup"><span data-stu-id="7a723-159">Generally, a Lightmap Resolution of around **25 texels per unit** should suffice (set resolution in the Lighting/Scene settings).</span></span>  <span data-ttu-id="7a723-160">Lightmap에 추가 공간이 있는 경우이 값을 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-160">If you have extra room in your lightmap, you can increase this value.</span></span>
* <span data-ttu-id="7a723-161">필요한 개체에 대해 해상도가 저장 되도록 개체당 **Lightmap 크기 조정** 설정을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-161">Change the **Lightmap Scaling** setting per object so that the resolution is saved for objects that need it.</span></span> 

* <span data-ttu-id="7a723-162">**Lightmap 크기 조정 차트** (thumb 규칙)</span><span class="sxs-lookup"><span data-stu-id="7a723-162">**Lightmap Scaling Chart** (rule of thumb)</span></span> 
    * <span data-ttu-id="7a723-163">**전경** (으로만 통과할 수준 지역): 1</span><span class="sxs-lookup"><span data-stu-id="7a723-163">**Foreground** (Traversable level geo): 1</span></span> 
    * <span data-ttu-id="7a723-164">**Props** (특히 인간 보다 작은 props): **2-3** (개체에서 lightmap 아티팩트와 조인트를 방지 하려면)</span><span class="sxs-lookup"><span data-stu-id="7a723-164">**Props** (especially props smaller than a human): **2-3** (to avoid lightmap artifacts and seams on your objects)</span></span> 
    * <span data-ttu-id="7a723-165">**Midground** (으로만 통과할 영역 바로 아래에 있는 Geometry 및/또는 빌딩과 같은 커다란 개체): **0.5**</span><span class="sxs-lookup"><span data-stu-id="7a723-165">**Midground** (Geometry that is just outside of the traversable area and/or large objects like buildings): **0.5**</span></span>
    * <span data-ttu-id="7a723-166">**배경** (Vista/먼 개체): **0.02**</span><span class="sxs-lookup"><span data-stu-id="7a723-166">**Background** (Vista/distant objects): **0.02**</span></span> 
    * <span data-ttu-id="7a723-167">**투명 한 표면** (예: 투명 표면): **0** (' 캐스트/수신 그림자 ' 사용 안 함)</span><span class="sxs-lookup"><span data-stu-id="7a723-167">**Transparent Surfaces** (like glass): **0** (with 'Cast/Receive Shadows’ disabled)</span></span> 

<span data-ttu-id="7a723-168">또한 다음과 같은 기본 설정을 사용 하 여 화면 도어 효과 환경에 사용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-168">Also, as a baseline, here are some settings that were used for the Screen Door Effect environment:</span></span>

![Unity의 조명 창](images/world-building-lightmaps.png)

## <a name="texture-compressionfile-size"></a><span data-ttu-id="7a723-170">**질감 압축/파일 크기**</span><span class="sxs-lookup"><span data-stu-id="7a723-170">**Texture Compression/File Size**</span></span>

* <span data-ttu-id="7a723-171">Android 빌드를 위해 Unity 패키지 장면 크기를 전체 10-20 약로 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-171">For our Android build, we try to keep our Unity package scene size down to around 10-20 MB total.</span></span>  <span data-ttu-id="7a723-172">이러한 작업은 여러 개체에서 일반 재질을 공유 하 고, 꼭 짓 점 색을 사용 하 여 개체에 색조를 설정 하 고, 질감이 기본 압축 보다 더 작은 **6x6 블록 압축** 을 사용 하도록 Android의 수동 재정의를 설정 하 여 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-172">We do this by sharing generic materials across many objects, using vertex color to tint the objects, and also by setting manual overrides for Android so that textures use **ASTC 6x6 block compression**, which will be smaller than the default compression.</span></span>

* <span data-ttu-id="7a723-173">Lightmaps를 사용 하도록 Android 빌드 설정을 설정 하지 않은 이유는이 압축 (많은 blocky 아티팩트)을 사용 하 여 제대로 표시 되지 않으며, lightmap를 사용 하도록 설정 해야 하기 때문입니다. 모든 굽기에서 lightmap의 압축 설정을 업데이트 하는 것 보다 모든 장면 질감에 대 한 재정의를 설정 하는 것이 더 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-173">The reason that we don't set the Android build settings to use ASTC is because lightmaps do not look good with that compression (lots of blocky artifacts), and we’d have to set the lightmap to use ETC after every bake, so it is easier instead to set up the override for all scene textures once than it is to update the lightmap’s compression settings after every bake.</span></span>

![Unity의 질감 창](images/world-building-texutres.png)

* <span data-ttu-id="7a723-175">또한 질감을 2로 설정 하 여 3 중 선형 필터 모드를 사용 하도록 설정 하면 glancing 각도로 선명 하 게 유지 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-175">Also, setting Textures to use Trilinear Filter Mode with a 2 Anisotropic Level can help them remain sharp at glancing angles.</span></span>

<span data-ttu-id="7a723-176">향상 된 성능 팁과 트릭은 [세계 성과 향상 설명서](improving-performance.md)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7a723-176">More performance tips and tricks can be found in the [Improving world performance documentation](improving-performance.md).</span></span>